/*
  单线程模型:
  JavaScript 中的线程模型是单线程模型, 同时只能执行一个任务, 其他任务都必须在后面排队等待
  JavaScript 只能在一个线程上运行(主线程), 不代表 JavaScript 引擎只有一个线程(其他线程都在后台配合)

  异步任务: 根本原因是执行效率 CPU >>> IO 系统
  IO 操作太慢, CPU 处于闲置状态, CPU 可以不管 IO 操作, 挂起处于等待中的任务, 先运行排在后面的任务, 等 IO 操作返回了
  结果, 再回过头, 把挂起的任务继续执行下去, 这就是 JavaScript 内部采取的 "事件循环" 机制
*/

/*
  同步任务和异步任务
  同步任务(在主线程排队执行的任务)
    没有挂起, 在主线程排队执行的任务, 只有前一个任务执行完毕, 才能执行后一个任务
  异步任务(进入任务队列的任务)
    挂起, 不进入主线程, 而是进入任务队列的任务, 只有引擎认为某个异步任务可以执行了(Ajax 操作从服务器得到了结果), 该
    任务(采用回调函数的形式)才会进入主线程执行, 排在异步任务后面的代码, 不用等待异步任务结束会马上运行
*/

/*
  任务队列和事件循环
  任务队列: 多个任务队列(多种异步任务) 等待全部同步任务执行完成, => 符合条件的异步任务进入主线程中执行
  任务队列清空, 程序执行结束

  回调函数
  一旦异步任务进入主线程, 就会执行对应的回调函数, 如果一个异步任务没有回调函数, 就不会进入任务队列(因为没有回调函数指定进入主线程后的下一步操作)

  事件循环
  一种循环检查的机制, 引擎一遍又一遍不停地检查, 只要同步任务执行完成了, 引擎就会去检查哪些挂起来的异步任务, 是不是可以进入主线程执行了
*/

/*
  异步任务的模式
  回调函数
  事件监听
  "发布/订阅"
*/
// 回调函数, 强耦合, 不利于维护和阅读, 回调地狱, 每个任务只能有一个回调函数
function f1() {}
function f2() {}
f1()
f2()
// 需求: f2 必须等待 f1 结束后再执行
function f1(callback) {
  // f1 的代码
  callback() /* f1 函数中耦合了 callback */
}
function f2() {}
f1(f2)

/**
 * 事件监听: 事件驱动模式, 异步任务的执行不取决于代码的顺序, 而取决于某个事件是否发生
 * 优点:
 *  函数之间解耦, 函数可以绑定多个事件, 每个事件可以指定多个回调函数
 * 缺点:
 *  程序变成了事件驱动型, 很难看出主流程
 */
f1.on('done', f2) // 当 f1 发生 done 事件的时候就执行 f2
// 改写
function f1() {
  setTimeout(() => {
    // 代码
    // 代码执行完成后, 立即触发 done 事件, 从而开始 f2 的执行
    // 或者说是任务进入主线程的标志, 事件的触发是任务进入主线程执行的标志
    f1.trigger('done')
  }, 1000)
}

// 发布/订阅, 信号 信号中心 观察者模式
/*
  "发布/订阅" 模式优于前面的 "事件驱动" 模式
  因为可以通过查询 "消息中心", 了解存在多少信号, 每个信号有多少订阅者, 从而监控程序的执行
*/
$.subscribe('done', f2) /* f2 订阅了 done 信号, 当某个任务执行完成, 向 "信号中心" 发送了 done 信号时, f2 由于订阅了 done 信号, 所以会接收到 done 信号, 从而知道是时候轮到自己开始执行了 */
function f1() {
  setTimeout(() => {
    // ... 代码
    // f1 的代码执行完成之后, 向信号中心 $ 发布 done 信号, 从而引发 f2 的执行
    // f1 执行完毕, 发布信号, f2 订阅这个信号, 知道自己应该执行了
    $.publish('done')
  }, 1000)
}

$.unsubscribe('done', f2) /* f2 执行完毕后, 可以取消订阅 */

/*
  多个异步操作, 存在一个流程控制的问题: 如何确定异步操作执行的顺序, 以及如何保证遵守这种顺序
  串行
  并行
  串并行(设置门槛, 每次最多只能并行执行 n 个异步任务, 避免过分占用系统资源)
*/

